<?php

/**
 * @file
 * Install, update and uninstall functions for the Varbase Security.
 */

use Symfony\Component\Yaml\Yaml;
use Drupal\Core\Config\InstallStorage;
use Drupal\Core\Config\StorageInterface;
use Drupal\Core\Config\FileStorage;
use Vardot\Entity\EntityDefinitionUpdateManager;

/**
 * Implements hook_install().
 */
function varbase_security_install() {

  $module_name = 'varbase_security';
  $module_path = Drupal::service('module_handler')->getModule('varbase_security')->getPath();

  // Processer for install: in [$module_name].info.yml file.
  // ---------------------------------------------------------------------------.
  $module_info_file = $module_path . '/' . $module_name . '.info.yml';
  if (file_exists($module_info_file)) {
    $module_info_data = (array) Yaml::parse(file_get_contents($module_info_file));
    if (isset($module_info_data['install'])
      && is_array($module_info_data['install'])) {

      foreach ($module_info_data['install'] as $module) {
        if (!\Drupal::moduleHandler()->moduleExists($module)) {
          \Drupal::service('module_installer')->install([$module], TRUE);
        }
      }

      _varbase_security_set_module_weight_after_installation($module_info_file);
    }
  }

  // Install optional configs.
  $optional_install_path = $module_path . '/' . InstallStorage::CONFIG_OPTIONAL_DIRECTORY;
  if (is_dir($optional_install_path)) {
    $config_installer = \Drupal::service('config.installer');
    $config_installer->installDefaultConfig('module', $module_name);

    // Create field storage configs first in active config.
    $storage_config_files = \Drupal::service('file_system')->scanDirectory($optional_install_path, '/^field.storage.*\\.(yml)$/i');
    if (isset($storage_config_files) && is_array($storage_config_files)) {
      foreach ($storage_config_files as $storage_config_file) {
        $storage_config_file_content = file_get_contents(DRUPAL_ROOT . '/' . $storage_config_file->uri);
        $storage_config_file_data = (array) Yaml::parse($storage_config_file_content);
        $config_factory = \Drupal::configFactory()->getEditable($storage_config_file->name);
        $config_factory->setData($storage_config_file_data)->save(TRUE);
      }
    }

    // Install any optional config the module provides.
    $storage = new FileStorage($optional_install_path, StorageInterface::DEFAULT_COLLECTION);
    $config_installer->installOptionalConfig($storage, '');

    // Have the .settings.yml configs into the active config.
    $settings_config_files = \Drupal::service('file_system')->scanDirectory($optional_install_path, '/^.*(settings.yml)$/i');
    if (isset($settings_config_files) && is_array($settings_config_files)) {
      foreach ($settings_config_files as $settings_config_file) {
        $settings_config_file_content = file_get_contents(DRUPAL_ROOT . '/' . $settings_config_file->uri);
        $settings_config_file_data = (array) Yaml::parse($settings_config_file_content);
        $config_factory = \Drupal::configFactory()->getEditable($settings_config_file->name);
        $config_factory->setData($settings_config_file_data)->save(TRUE);
      }
    }
  }
  // ---------------------------------------------------------------------------
  // Entity updates to clear up any mismatched entity and/or field definitions
  // And Fix changes were detected in the entity type and field definitions.
  \Drupal::classResolver()
    ->getInstanceFromDefinition(EntityDefinitionUpdateManager::class)
    ->applyUpdates();

  // Have forced configs import after the entity and definitions updates.
  $forced_configs_import_after_entity_updates = [
    'core.entity_form_display.user.user.default',
  ];

  foreach ($forced_configs_import_after_entity_updates as $config_name) {
    $config_path = $optional_install_path . '/' . $config_name . '.yml';
    $config_content = file_get_contents($config_path);
    $config_data = (array) Yaml::parse($config_content);
    $config_factory = \Drupal::configFactory()->getEditable($config_name);
    $config_factory->setData($config_data)->save(TRUE);
  }

}

/**
 * Get set module waht after installation.
 *
 * @param string $file_name
 *   The file name and path the varbase_security.info.yml.
 */
function _varbase_security_set_module_weight_after_installation(string $file_name) {
  // Get all modules from core.extension.
  $installed_modules = (array) \Drupal::service('config.factory')->getEditable('core.extension')->get('module');
  // Get weight of varbase security.
  $varbase_security_weight = $installed_modules['varbase_security'];
  // Get all modules installed by varbase security.
  $varbase_security_modules = (array) Yaml::parse(file_get_contents($file_name))['install'];
  // Empty array to put all modules weight [modules installed].
  $varase_security_modules_weight = [];

  foreach ($installed_modules as $module => $weight) {
    foreach ($varbase_security_modules as $vs_module_key => $vs_module_name) {
      if ($module === $vs_module_name) {
        $varase_security_modules_weight += [$module => $weight];
      }
    }
  }

  // Get max weight of modules installed by varbase_security.
  $max_wight = max($varase_security_modules_weight);

  // Set varbase_security weight to be grater than higher one by 1 if it's
  // less than or equal to max.
  if ($varbase_security_weight <= $max_wight) {
    module_set_weight('varbase_security', $max_wight + 1);
  }

  module_set_weight('varbase_security', $max_wight + 1);
}

/**
 * Add Flood Control module for login attempt limiting.
 *
 * And remove the Flood Unblock module as it will be
 * discontinued by its maintainers.
 */
function varbase_security_update_9001() {

  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('varbase_core', 'varbase_security_update_9001');

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Reinforce spam protection and enable "Honeypot" spam detection.
 *
 * Enabling protection on a wider forms and enabling time limit of 2 seconds.
 */
function varbase_security_update_9002() {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('varbase_core', 'varbase_security_update_9002');

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Issue #3252064: Add Antibot module with config to Varbase Security.
 *
 * Reinforce spam protection via the "Antibot" spam detection mechanism.
 */
function varbase_security_update_9003() {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('varbase_core', 'varbase_security_update_9003');

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Issue #3265975: Fix errors on validating Security Review.
 *
 * Config synchronization when the module is not enabled yet.
 */
function varbase_security_update_9004() {
  if (!\Drupal::moduleHandler()->moduleExists('security_review')) {
    // Managed configs for the Security Review module.
    $managed_configs = [
      'security_review.settings',
      'security_review.check.security_review-admin_permissions',
      'security_review.check.security_review-error_reporting',
      'security_review.check.security_review-executable_php',
      'security_review.check.security_review-failed_logins',
      'security_review.check.security_review-field',
      'security_review.check.security_review-file_perms',
      'security_review.check.security_review-input_formats',
      'security_review.check.security_review-private_files',
      'security_review.check.security_review-query_errors',
      'security_review.check.security_review-temporary_files',
      'security_review.check.security_review-trusted_hosts',
      'security_review.check.security_review-upload_extensions',
      'security_review.check.security_review-views_access',
    ];

    // Delete all Security Review configs if the module is not enable yet.
    // Which they will be imported again after installing the module.
    foreach ($managed_configs as $config_name) {
      \Drupal::configFactory()->getEditable($config_name)->delete();
    }
  }
}

/**
 * Issue #3256029: Fix Revise password policy and password suggestions message.
 *
 * Change varbase security weight and make it after all modules installed by it.
 */
function varbase_security_update_90004() {

  $module_path = Drupal::service('module_handler')->getModule('varbase_security')->getPath();
  $module_info_file = $module_path . '/varbase_security.info.yml';
  if (file_exists($module_info_file)) {
    $module_info_data = (array) Yaml::parse(file_get_contents($module_info_file));
    if (isset($module_info_data['install'])
      && is_array($module_info_data['install'])) {
      _varbase_security_set_module_weight_after_installation($module_info_file);
    }
  }

  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('varbase_core', 'varbase_security_update_90004');

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}
